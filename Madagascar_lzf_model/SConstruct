import os, sys, re, string
sys.path.append('../../framework')
import bldutil





progs = '''estimateinterference
'''
ccprogs = '''
'''

#ccprogs = '''
#dblendcurvelet2
#'''

subs = '''

'''
# mutter3

mpiprogs=''

cprogs = '''

'''

tprogs='''
'''
pyprogs='''
'''
pymods='''

'''

docs = []

try: # distributed version
    Import('env root pkgdir bindir')
    env = env.Clone()
except: # local version
    env = bldutil.Debug()
    root = None
    SConscript('../pwd/SConstruct')
src = Glob('[a-z]*.c')
dynpre = env.get('DYNLIB','')

libs = [dynpre+'rsf']+env.get('LIBS',[])
dlibs = ['drsf']+env.get('LIBS',[])

lapack = env.get('LAPACK')

env.Prepend(CPPPATH=['../../include'],
            LIBPATH=['../../lib'],
            LIBS=[dynpre+'rsfpwd',dynpre+'rsf'])
#env.Prepend(LIBS='fftw3')

for source in src:
    inc = env.RSF_Include(source,prefix='')
    obj = env.StaticObject(source)
    env.Ignore(inc,inc)
    env.Depends(obj,inc)

######################################################################
#USING PETSC (One should specify the absolute dir in petsccpp and petsclib.)
######################################################################

petsccpp=os.environ.get("PETSCCPP")
petsclib=os.environ.get("PETSCLIB")

if petsclib:
    env.Prepend(CPPPATH=[petsccpp],
            LIBPATH=[petsclib],
            LIBS='')
    libs = [libs, 'petsc']

######################################################################
# Compiling main programs
######################################################################

mains = Split(progs)
for prog in mains:
    sources = ['M' + prog]
    bldutil.depends(env,sources,'M'+prog)
    prog = env.Program(prog,[x+'.c' for x in sources])
    if root:
        env.Install(bindir,prog)

######################################################################
# Compiling c++ programs
######################################################################


ccmains = Split(ccprogs)
for prog in ccmains:
    sources = ['M' + prog]
    if 'c++' in env.get('API',[]):
        lapack = env.get('LAPACK')
        libs = [env.get('DYNLIB','')+'rsf++',
                env.get('DYNLIB','')+'rsf']
        if not isinstance(lapack,bool):
            libs.extend(lapack)
        env.Prepend(CPPPATH=['../../include'],
                    LIBPATH=['../../lib'],
                    LIBS=libs)
        env.Prepend(CPPPATH=['../../build/include'],
                    LIBPATH=['../../build/lib'],
                    LIBS=libs)
        libss = [env.get('DYNLIB','')+'fftw']
        env.Prepend(CPPPATH=['/usr/local/fftw/include'],
                    LIBPATH=['/usr/local/fftw/lib'],
                    LIBS=libss)
        ccfiles = [x +'.cc', Split(subs)]
        lib = env.StaticLibrary('fdct_wrapping',ccfiles,CCFLAGS='-Wunused-variable -Wsign-compare')
        env.Install('../../lib',lib)
        prog = env.Program(prog,[x+'.cc', sources],
                            LIBS = [dynpre+'rsf++']+libs+lib+libss)
        if root:
            install = env.Install(bindir,prog)

            if dynpre and env['PLATFORM'] == 'darwin':
                env.AddPostAction(install,
                                  '%s -change build/api/c/libdrsf.dylib '
                                  '%s/libdrsf.dylib %s' % \
                                  (WhereIs('install_name_tool'),libdir,install[0]))
                env.AddPostAction(install,
                                  '%s -change build/api/c++/libdrsf++.dylib '
                                  '%s/libdrsf++.dylib %s' % \
                                  (WhereIs('install_name_tool'),libdir,install[0]))
    else:
        prog = env.RSF_Place('sf'+prog,None,package='c++')
        if root:
            env.Install(bindir,prog)

######################################################################
# Compiling mpi programs ("MPILIB MPICPP" is user defined.)
######################################################################

mpicc  = env.get('MPICC')
mpimains = Split(mpiprogs)

mpilib = os.environ.get("MPILIB")
mpicpp = os.environ.get("MPICPP")


######################################################################
# compiling CUDA programs
######################################################################
CTP = env.get('CUDA_TOOLKIT_PATH')
NVCC = env.get('NVCC')

cuda_mains = Split(cprogs)
for prog in cuda_mains:
    if CTP and NVCC:
        cfile = env.Command('CUDA'+prog+'.c','M'+prog+'.cu','cp $SOURCE $TARGET')
        cc = env.get('CC')
        cflags = '--x=cu -O'
        ldflags = '-lcublas -lcufft -lcusparse'
        if string.rfind(cc,'icc') >= 0:
            cflags = cflags + ' -ccbin=%s' % cc
            ldflags = '-ccbin=%s' % cc
        prog = env.Program(prog,cfile,
                           CC=NVCC,
                           LINKFLAGS=ldflags,
                           CFLAGS=cflags)
    else:
        prog = env.RSF_Place('sf'+prog,None,
                             message='''
                             Please check if CUDA is not missing and is installed correctly.
                             Rerun Madagascar installation after it has been fixed.
                             ''')
    if root:
        env.Install(bindir,prog)

######################################################################
# Compiling testing programs
######################################################################

tmains = Split(tprogs)
for prog in tmains:
    if lapack:
    	sources = ['Test' + prog]
    	if prog=='clapack':
           sources.append('solver')
    	bldutil.depends(env,sources,'Test'+prog)
    	sources = [x+'.o', sources]
    	env.Object('Test' + prog + '.c')
    	prog=env.Program(sources,PROGPREFIX='',PROGSUFFIX='.x',LIBS=libs)

######################################################################
# PYTHON METAPROGRAMS (python API not needed)
######################################################################

if root: # no compilation, just rename
	pymains = Split(pyprogs)
	exe = env.get('PROGSUFFIX','')
	for prog in pymains:
		env.InstallAs(os.path.join(bindir,'sf'+prog+exe),'M'+prog+'.py')
	bldutil.install_py_modules(env,Split(pymods),pkgdir)

######################################################################
# SELF-DOCUMENTATION
######################################################################
if root:
	user = os.path.basename(os.getcwd())
	main = 'sf%s.py' % user

	docs += [env.Doc(prog,'M' + prog) for prog in mains]  + \
           [env.Doc(prog,'M%s.cc' % prog,lang='c++') for prog in ccmains] + \
           [env.Doc(prog,'M' + prog) for prog in mpimains] + \
		[env.Doc(prog,'M'+prog+'.py',lang='python') for prog in pymains]
	env.Depends(docs,'#/framework/rsf/doc.py')
	doc = env.RSF_Docmerge(main,docs)
	env.Install(pkgdir,doc)


